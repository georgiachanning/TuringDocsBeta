<!DOCTYPE html><HTML lang="en"><head><script charset="utf-8" src="../../assets/__default/flexsearch.bundle.js" type="text/javascript"></script><script charset="utf-8" src="../../assets/__default/flexsearch_integration.js" type="text/javascript"></script><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>AdvancedHMC.jl · AdvancedHMC</title><script data-outdated-warner="" src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script data-main="assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" data-theme-name="documenter-dark" data-theme-primary-dark="" href="assets/themes/documenter-dark.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" data-theme-name="documenter-light" data-theme-primary="" href="assets/themes/documenter-light.css" rel="stylesheet" type="text/css"/><script src="assets/themeswap.js"></script><script src="https://cdn.tailwindcss.com"></script><style>#turing-navbar {
    display: inline-block;
    width: calc(100% - 18rem);
    margin-left: 18rem;
    margin-bottom: 0;
}</style><link href="../../assets/__default/multidoc.css" rel="stylesheet" type="text/css"/><link href="../../assets/__default/flexsearch.css" rel="stylesheet" type="text/css"/></head><body><nav id="multi-page-nav"><div class="hidden-on-mobile" id="nav-items"><a class="nav-link nav-item" href="../../ppl/">DynamicPPL</a><a class="nav-link active nav-item" href="../">AdvancedHMC</a><div class="search nav-item"><input id="search-input" placeholder="Search..."/><ul class="suggestions hidden" id="search-result-container"></ul><div class="search-keybinding">/</div></div></div><a id="multidoc-toggler"></a></nav><header class="h-14 w-full px-6 py-3 z-50 text-slate-200 font-sans font-normal bg-[#073c44] shadow shadow-[#073c44]" id="turing-navbar"><nav class="float-left block mt-1"><a class="text-base pr-2" href="/">Home</a><a class="text-base px-2" href="/guides/get-started/">Get Started</a><a class="text-base px-2" href="/guides/">Guides</a><a class="text-base px-2" href="/tutorials/">Tutorials</a><a class="text-base px-2" href="/docs/">Docs</a><a class="text-base px-2" href="/news/">News</a><a class="text-base pl-2" href="/team/">Team</a></nav><div class="float-right"><a class="text-2xl px-1 pl-48" href="https://github.com/TuringLang" style="background-image: url(&#39;/assets/turing-logo-wide.svg&#39;);">The Turing Language</a><a href="https://github.com/TuringLang/Turing.jl"><img alt="GitHub Repo stars" class="inline px-1" src="https://img.shields.io/github/stars/turinglang/Turing.jl?style=social"/></a><a href="https://twitter.com/TuringLang"><img alt="Twitter Follow" class="inline px-1" src="https://img.shields.io/twitter/follow/TuringLang?style=social"/></a></div></header><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="">AdvancedHMC</a></span></div><form action="search/" class="docs-search"><input class="docs-search-query" id="documenter-search-query" name="q" placeholder="Search docs" type="text"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href="">AdvancedHMC.jl</a><ul class="internal"><li><a class="tocitem" href="#A-minimal-example-sampling-from-a-multivariate-Gaussian-using-NUTS"><span>A minimal example - sampling from a multivariate Gaussian using NUTS</span></a></li><li><a class="tocitem" href="#API-and-supported-HMC-algorithms"><span>API and supported HMC algorithms</span></a></li><li><a class="tocitem" href="#The-sample-function-signature-in-detail"><span>The <code>sample</code> function signature in detail</span></a></li><li><a class="tocitem" href="#Citing-AdvancedHMC.jl"><span>Citing AdvancedHMC.jl</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="api/">AdvancedHMC.jl</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="">AdvancedHMC.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="">AdvancedHMC.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/TuringLang/AdvancedHMC.jl/blob/master/README.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" href="#" id="documenter-settings-button" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" href="#" id="documenter-sidebar-button"></a></div></header><article class="content" id="documenter-page"><h1 id="AdvancedHMC.jl"><a class="docs-heading-anchor" href="#AdvancedHMC.jl">AdvancedHMC.jl</a><a id="AdvancedHMC.jl-1"></a><a class="docs-heading-anchor-permalink" href="#AdvancedHMC.jl" title="Permalink"></a></h1><p><a href="https://github.com/TuringLang/AdvancedHMC.jl/actions?query=workflow%3AAdvancedHMC-CI"><img alt="AdvancedHMC-CI" src="https://github.com/TuringLang/AdvancedHMC.jl/workflows/AdvancedHMC-CI/badge.svg?branch=master"/></a><a href="https://zenodo.org/badge/latestdoi/72657907"><img alt="DOI" src="https://zenodo.org/badge/72657907.svg"/></a><a href="https://coveralls.io/github/TuringLang/AdvancedHMC.jl?branch=kx%2Fbug-fix"><img alt="Coverage Status" src="https://coveralls.io/repos/github/TuringLang/AdvancedHMC.jl/badge.svg?branch=kx%2Fbug-fix"/></a><a href="https://turing.ml/stable/docs/library/advancedhmc/"><img alt="Stable" src="https://img.shields.io/badge/docs-stable-blue.svg"/></a><a href="https://turinglang.github.io/AdvancedHMC.jl/dev/"><img alt="Dev" src="https://img.shields.io/badge/docs-dev-blue.svg"/></a></p><p>AdvancedHMC.jl provides a robust, modular and efficient implementation of advanced HMC algorithms. An illustrative example for AdvancedHMC's usage is given below. AdvancedHMC.jl is part of <a href="https://github.com/TuringLang/Turing.jl">Turing.jl</a>, a probabilistic programming library in Julia.  If you are interested in using AdvancedHMC.jl through a probabilistic programming language, please check it out!</p><p><strong>Interfaces</strong></p><ul><li><a href="https://github.com/salilab/hmc"><code>IMP.hmc</code></a>: an experimental Python module for the Integrative Modeling Platform, which uses AdvancedHMC in its backend to sample protein structures.</li></ul><p><strong>NEWS</strong></p><ul><li>We presented a paper for AdvancedHMC.jl at <a href="http://approximateinference.org/">AABI</a> 2019 in Vancouver, Canada. (<a href="http://proceedings.mlr.press/v118/xu20a.html">abs</a>, <a href="http://proceedings.mlr.press/v118/xu20a/xu20a.pdf">pdf</a>, <a href="https://openreview.net/forum?id=rJgzckn4tH">OpenReview</a>)</li><li>We presented a poster for AdvancedHMC.jl at <a href="https://mc-stan.org/events/stancon2019Cambridge/">StanCon 2019</a> in Cambridge, UK. (<a href="https://github.com/TuringLang/AdvancedHMC.jl/files/3730367/StanCon-AHMC.pdf">pdf</a>)</li></ul><p><strong>API CHANGES</strong></p><ul><li>[v0.2.22] Three functions are renamed.<ul><li><code>Preconditioner(metric::AbstractMetric)</code> -&gt; <code>MassMatrixAdaptor(metric)</code> and </li><li><code>NesterovDualAveraging(δ, integrator::AbstractIntegrator)</code> -&gt; <code>StepSizeAdaptor(δ, integrator)</code></li><li><code>find_good_eps</code> -&gt; <code>find_good_stepsize</code></li></ul></li><li>[v0.2.15] <code>n_adapts</code> is no longer needed to construct <code>StanHMCAdaptor</code>; the old constructor is deprecated.</li><li>[v0.2.8] Two Hamiltonian trajectory sampling methods are renamed to avoid a name clash with Distributions.<ul><li><code>Multinomial</code> -&gt; <code>MultinomialTS</code></li><li><code>Slice</code> -&gt; <code>SliceTS</code></li></ul></li><li>[v0.2.0] The gradient function passed to <code>Hamiltonian</code> is supposed to return a value-gradient tuple now.</li></ul><h2 id="A-minimal-example-sampling-from-a-multivariate-Gaussian-using-NUTS"><a class="docs-heading-anchor" href="#A-minimal-example-sampling-from-a-multivariate-Gaussian-using-NUTS">A minimal example - sampling from a multivariate Gaussian using NUTS</a><a id="A-minimal-example-sampling-from-a-multivariate-Gaussian-using-NUTS-1"></a><a class="docs-heading-anchor-permalink" href="#A-minimal-example-sampling-from-a-multivariate-Gaussian-using-NUTS" title="Permalink"></a></h2><pre><code class="language-julia hljs">using AdvancedHMC, Distributions, ForwardDiff
using LinearAlgebra

# Choose parameter dimensionality and initial parameter value
D = 10; initial_θ = rand(D)

# Define the target distribution
ℓπ(θ) = logpdf(MvNormal(zeros(D), I), θ)

# Set the number of samples to draw and warmup iterations
n_samples, n_adapts = 2_000, 1_000

# Define a Hamiltonian system
metric = DiagEuclideanMetric(D)
hamiltonian = Hamiltonian(metric, ℓπ, ForwardDiff)

# Define a leapfrog solver, with initial step size chosen heuristically
initial_ϵ = find_good_stepsize(hamiltonian, initial_θ)
integrator = Leapfrog(initial_ϵ)

# Define an HMC sampler, with the following components
#   - multinomial sampling scheme,
#   - generalised No-U-Turn criteria, and
#   - windowed adaption for step-size and diagonal mass matrix
proposal = NUTS{MultinomialTS, GeneralisedNoUTurn}(integrator)
adaptor = StanHMCAdaptor(MassMatrixAdaptor(metric), StepSizeAdaptor(0.8, integrator))

# Run the sampler to draw samples from the specified Gaussian, where
#   - `samples` will store the samples
#   - `stats` will store diagnostic statistics for each sample
samples, stats = sample(hamiltonian, proposal, initial_θ, n_samples, adaptor, n_adapts; progress=true)</code></pre><h3 id="Parallel-sampling"><a class="docs-heading-anchor" href="#Parallel-sampling">Parallel sampling</a><a id="Parallel-sampling-1"></a><a class="docs-heading-anchor-permalink" href="#Parallel-sampling" title="Permalink"></a></h3><p>AdvancedHMC enables parallel sampling (either distributed or multi-thread) via Julia's <a href="https://docs.julialang.org/en/v1/manual/parallel-computing/">parallel computing functions</a>. It also supports vectorized sampling for static HMC and has been discussed in more detail in the documentation <a href="https://turing.ml/dev/docs/library/advancedhmc/parallel_sampling">here</a>.</p><p>The below example utilizes the <code>@threads</code> macro to sample 4 chains across 4 threads.</p><pre><code class="language-julia hljs"># Ensure that julia was launched with appropriate number of threads
println(Threads.nthreads())

# Number of chains to sample
nchains = 4

# Cache to store the chains
chains = Vector{Any}(undef, nchains)

# The `samples` from each parallel chain is stored in the `chains` vector 
# Adjust the `verbose` flag as per need
Threads.@threads for i in 1:nchains
  samples, stats = sample(hamiltonian, proposal, initial_θ, n_samples, adaptor, n_adapts; verbose=false)
  chains[i] = samples
end</code></pre><h3 id="GPU-Sampling-with-CUDA"><a class="docs-heading-anchor" href="#GPU-Sampling-with-CUDA">GPU Sampling with CUDA</a><a id="GPU-Sampling-with-CUDA-1"></a><a class="docs-heading-anchor-permalink" href="#GPU-Sampling-with-CUDA" title="Permalink"></a></h3><p>There is experimental support for running static HMC on the GPU using CUDA.  To do so the user needs to have <a href="https://github.com/JuliaGPU/CUDA.jl">CUDA.jl</a> installed, ensure the logdensity of the <code>Hamiltonian</code> can be executed on the GPU and that the initial points are a <code>CuArray</code>.  A small working example can be found at <code>test/cuda.jl</code>.</p><h2 id="API-and-supported-HMC-algorithms"><a class="docs-heading-anchor" href="#API-and-supported-HMC-algorithms">API and supported HMC algorithms</a><a id="API-and-supported-HMC-algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#API-and-supported-HMC-algorithms" title="Permalink"></a></h2><p>An important design goal of AdvancedHMC.jl is modularity; we would like to support algorithmic research on HMC. This modularity means that different HMC variants can be easily constructed by composing various components, such as preconditioning metric (i.e. mass matrix), leapfrog integrators,  trajectories (static or dynamic), and adaption schemes etc.  The minimal example above can be modified to suit particular inference problems by picking components from the list below.</p><h3 id="Hamiltonian-mass-matrix-(metric)"><a class="docs-heading-anchor" href="#Hamiltonian-mass-matrix-(metric)">Hamiltonian mass matrix (<code>metric</code>)</a><a id="Hamiltonian-mass-matrix-(metric)-1"></a><a class="docs-heading-anchor-permalink" href="#Hamiltonian-mass-matrix-(metric)" title="Permalink"></a></h3><ul><li>Unit metric: <code>UnitEuclideanMetric(dim)</code></li><li>Diagonal metric: <code>DiagEuclideanMetric(dim)</code></li><li>Dense metric: <code>DenseEuclideanMetric(dim)</code></li></ul><p>where <code>dim</code> is the dimensionality of the sampling space.</p><h3 id="Integrator-(integrator)"><a class="docs-heading-anchor" href="#Integrator-(integrator)">Integrator (<code>integrator</code>)</a><a id="Integrator-(integrator)-1"></a><a class="docs-heading-anchor-permalink" href="#Integrator-(integrator)" title="Permalink"></a></h3><ul><li>Ordinary leapfrog integrator: <code>Leapfrog(ϵ)</code></li><li>Jittered leapfrog integrator with jitter rate <code>n</code>: <code>JitteredLeapfrog(ϵ, n)</code></li><li>Tempered leapfrog integrator with tempering rate <code>a</code>: <code>TemperedLeapfrog(ϵ, a)</code></li></ul><p>where <code>ϵ</code> is the step size of leapfrog integration.</p><h3 id="Proposal-(proposal)"><a class="docs-heading-anchor" href="#Proposal-(proposal)">Proposal (<code>proposal</code>)</a><a id="Proposal-(proposal)-1"></a><a class="docs-heading-anchor-permalink" href="#Proposal-(proposal)" title="Permalink"></a></h3><ul><li>Static HMC with a fixed number of steps (<code>n_steps</code>) (Neal, R. M. (2011)): <code>StaticTrajectory(integrator, n_steps)</code></li><li>HMC with a fixed total trajectory length (<code>trajectory_length</code>) (Neal, R. M. (2011)): <code>HMCDA(integrator, trajectory_length)</code></li><li>Original NUTS with slice sampling (Hoffman, M. D., &amp; Gelman, A. (2014)): <code>NUTS{SliceTS,ClassicNoUTurn}(integrator)</code></li><li>Generalised NUTS with slice sampling (Betancourt, M. (2017)): <code>NUTS{SliceTS,GeneralisedNoUTurn}(integrator)</code></li><li>Original NUTS with multinomial sampling (Betancourt, M. (2017)): <code>NUTS{MultinomialTS,ClassicNoUTurn}(integrator)</code></li><li>Generalised NUTS with multinomial sampling (Betancourt, M. (2017)): <code>NUTS{MultinomialTS,GeneralisedNoUTurn}(integrator)</code></li></ul><h3 id="Adaptor-(adaptor)"><a class="docs-heading-anchor" href="#Adaptor-(adaptor)">Adaptor (<code>adaptor</code>)</a><a id="Adaptor-(adaptor)-1"></a><a class="docs-heading-anchor-permalink" href="#Adaptor-(adaptor)" title="Permalink"></a></h3><ul><li>Adapt the mass matrix <code>metric</code> of the Hamiltonian dynamics: <code>mma = MassMatrixAdaptor(metric)</code><ul><li>This is lowered to <code>UnitMassMatrix</code>, <code>WelfordVar</code> or <code>WelfordCov</code> based on the type of the mass matrix <code>metric</code></li></ul></li><li>Adapt the step size of the leapfrog integrator <code>integrator</code>: <code>ssa = StepSizeAdaptor(δ, integrator)</code><ul><li>It uses Nesterov's dual averaging with <code>δ</code> as the target acceptance rate.</li></ul></li><li>Combine the two above <em>naively</em>: <code>NaiveHMCAdaptor(mma, ssa)</code></li><li>Combine the first two using Stan's windowed adaptation: <code>StanHMCAdaptor(mma, ssa)</code></li></ul><h3 id="Gradients"><a class="docs-heading-anchor" href="#Gradients">Gradients</a><a id="Gradients-1"></a><a class="docs-heading-anchor-permalink" href="#Gradients" title="Permalink"></a></h3><p><code>AdvancedHMC</code> supports both AD-based (<code>Zygote</code>, <code>Tracker</code> and <code>ForwardDiff</code>) and user-specified gradients. In order to use user-specified gradients, please replace <code>ForwardDiff</code> with <code>ℓπ_grad</code> in the <code>Hamiltonian</code>  constructor, where the gradient function <code>ℓπ_grad</code> should return a tuple containing both the log-posterior and its gradient. </p><p>All the combinations are tested in <a href="https://github.com/TuringLang/AdvancedHMC.jl/blob/master/test/sampler.jl">this file</a> except from using tempered leapfrog integrator together with adaptation, which we found unstable empirically.</p><h2 id="The-sample-function-signature-in-detail"><a class="docs-heading-anchor" href="#The-sample-function-signature-in-detail">The <code>sample</code> function signature in detail</a><a id="The-sample-function-signature-in-detail-1"></a><a class="docs-heading-anchor-permalink" href="#The-sample-function-signature-in-detail" title="Permalink"></a></h2><pre><code class="language-julia hljs">function sample(
    rng::Union{AbstractRNG, AbstractVector{&lt;:AbstractRNG}},
    h::Hamiltonian,
    κ::HMCKernel,
    θ::AbstractVector{&lt;:AbstractFloat},
    n_samples::Int,
    adaptor::AbstractAdaptor=NoAdaptation(),
    n_adapts::Int=min(div(n_samples, 10), 1_000);
    drop_warmup=false,
    verbose::Bool=true,
    progress::Bool=false,
)</code></pre><p>Draw <code>n_samples</code> samples using the proposal <code>κ</code> under the Hamiltonian system <code>h</code></p><ul><li>The randomness is controlled by <code>rng</code>.<ul><li>If <code>rng</code> is not provided, <code>GLOBAL_RNG</code> will be used.</li></ul></li><li>The initial point is given by <code>θ</code>.</li><li>The adaptor is set by <code>adaptor</code>, for which the default is no adaptation.<ul><li>It will perform <code>n_adapts</code> steps of adaptation, for which the default is <code>1_000</code> or 10% of <code>n_samples</code>, whichever is lower. </li></ul></li><li><code>drop_warmup</code> specifies whether to drop samples.</li><li><code>verbose</code> controls the verbosity.</li><li><code>progress</code> controls whether to show the progress meter or not.</li></ul><p>Note that the function signature of the <code>sample</code> function exported by <code>AdvancedHMC.jl</code> differs from the <a href="https://turing.ml/dev/docs/using-turing/guide#modelling-syntax-explained"><code>sample</code></a> function used by <code>Turing.jl</code>. We refer to the documentation of <code>Turing.jl</code> for more details on the latter.</p><h2 id="Citing-AdvancedHMC.jl"><a class="docs-heading-anchor" href="#Citing-AdvancedHMC.jl">Citing AdvancedHMC.jl</a><a id="Citing-AdvancedHMC.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Citing-AdvancedHMC.jl" title="Permalink"></a></h2><p>If you use AdvancedHMC.jl for your own research, please consider citing the following publication:</p><p>Kai Xu, Hong Ge, Will Tebbutt, Mohamed Tarek, Martin Trapp, Zoubin Ghahramani: "AdvancedHMC.jl: A robust, modular and efficient implementation of advanced HMC algorithms.", <em>Symposium on Advances in Approximate Bayesian Inference</em>, 2020. (<a href="http://proceedings.mlr.press/v118/xu20a.html">abs</a>, <a href="http://proceedings.mlr.press/v118/xu20a/xu20a.pdf">pdf</a>)</p><p>with the following BibTeX entry:</p><pre><code class="nohighlight hljs">@inproceedings{xu2020advancedhmc,
  title={AdvancedHMC. jl: A robust, modular and efficient implementation of advanced HMC algorithms},
  author={Xu, Kai and Ge, Hong and Tebbutt, Will and Tarek, Mohamed and Trapp, Martin and Ghahramani, Zoubin},
  booktitle={Symposium on Advances in Approximate Bayesian Inference},
  pages={1--10},
  year={2020},
  organization={PMLR}
}</code></pre><p>If you using AdvancedHMC.jl directly through Turing.jl, please consider citing the following publication:</p><p>Hong Ge, Kai Xu, and Zoubin Ghahramani: "Turing: a language for flexible probabilistic inference.", <em>International Conference on Artificial Intelligence and Statistics</em>, 2018. (<a href="http://proceedings.mlr.press/v84/ge18b.html">abs</a>, <a href="http://proceedings.mlr.press/v84/ge18b/ge18b.pdf">pdf</a>)</p><p>with the following BibTeX entry:</p><pre><code class="nohighlight hljs">@inproceedings{ge2018turing,
  title={Turing: A language for flexible probabilistic inference},
  author={Ge, Hong and Xu, Kai and Ghahramani, Zoubin},
  booktitle={International Conference on Artificial Intelligence and Statistics},
  pages={1682--1690},
  year={2018},
  organization={PMLR}
}</code></pre><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><ol><li><p>Neal, R. M. (2011). MCMC using Hamiltonian dynamics. Handbook of Markov chain Monte Carlo, 2(11), 2. (<a href="https://arxiv.org/pdf/1206.1901">arXiv</a>)</p></li><li><p>Betancourt, M. (2017). A Conceptual Introduction to Hamiltonian Monte Carlo. <a href="https://arxiv.org/abs/1701.02434">arXiv preprint arXiv:1701.02434</a>.</p></li><li><p>Girolami, M., &amp; Calderhead, B. (2011). Riemann manifold Langevin and Hamiltonian Monte Carlo methods. Journal of the Royal Statistical Society: Series B (Statistical Methodology), 73(2), 123-214. (<a href="https://rss.onlinelibrary.wiley.com/doi/full/10.1111/j.1467-9868.2010.00765.x">arXiv</a>)</p></li><li><p>Betancourt, M. J., Byrne, S., &amp; Girolami, M. (2014). Optimizing the integrator step size for Hamiltonian Monte Carlo. <a href="https://arxiv.org/pdf/1411.6669">arXiv preprint arXiv:1411.6669</a>.</p></li><li><p>Betancourt, M. (2016). Identifying the optimal integration time in Hamiltonian Monte Carlo. <a href="https://arxiv.org/abs/1601.00225">arXiv preprint arXiv:1601.00225</a>.</p></li><li><p>Hoffman, M. D., &amp; Gelman, A. (2014). The No-U-Turn Sampler: adaptively setting path lengths in Hamiltonian Monte Carlo. Journal of Machine Learning Research, 15(1), 1593-1623. (<a href="http://arxiv.org/abs/1111.4246">arXiv</a>)</p></li></ol></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="api/">AdvancedHMC.jl »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label></p><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div><p></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Tuesday 6 September 2022 08:58">Tuesday 6 September 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></HTML>